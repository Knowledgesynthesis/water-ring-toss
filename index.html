<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="mobile-web-app-capable" content="yes" />
<title>Water Ring Toss 3D</title>
<style>
  :root{
    --bg:#0a0e1a;
    --glass: rgba(255,255,255,0.08);
    --ink:#e5f0ff;
    --good:#34d399;
  }
  *{box-sizing:border-box; margin:0; padding:0;}
  html,body{
    height:100%;
    overflow:hidden;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
    font-family: system-ui,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif;
  }
  body{
    background: radial-gradient(120% 120% at 50% 0%, #0b1327 10%, #071022 55%, #060a14 100%);
    color:var(--ink);
  }

  #container{
    width:100vw;
    height:100vh;
    position:relative;
  }

  canvas{
    display:block;
    width:100%;
    height:100%;
  }

  /* HUD */
  .hud{
    position:absolute;
    top:0;
    left:0;
    right:0;
    z-index:10;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    padding:clamp(12px, 2vh, 16px);
    pointer-events:none;
  }

  .cluster{
    display:flex;
    gap:clamp(6px, 1vw, 10px);
    pointer-events:auto;
  }

  .pill{
    background: var(--glass);
    backdrop-filter: blur(12px);
    border:1px solid rgba(255,255,255,0.12);
    padding:clamp(8px, 1.5vh, 12px) clamp(12px, 2vw, 16px);
    border-radius:999px;
    font-weight:600;
    font-size:clamp(12px, 2.5vw, 15px);
    display:flex;
    align-items:center;
    gap:clamp(6px, 1vw, 8px);
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    min-height:clamp(36px, 5vh, 44px);
    white-space:nowrap;
  }

  .score{color:var(--good)}

  .btn{
    background: var(--glass);
    backdrop-filter: blur(12px);
    border:1px solid rgba(255,255,255,0.15);
    color:var(--ink);
    padding:clamp(8px, 1.5vh, 12px) clamp(12px, 2vw, 16px);
    border-radius:clamp(10px, 2vw, 12px);
    cursor:pointer;
    font-weight:600;
    font-size:clamp(12px, 2.5vw, 14px);
    display:inline-flex;
    align-items:center;
    gap:clamp(6px, 1vw, 8px);
    transition:transform .1s ease, background .15s ease;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    min-height:clamp(38px, 5.5vh, 46px);
    white-space:nowrap;
  }
  .btn:active{transform: translateY(1px)}
  .btn:hover{background: rgba(255,255,255,0.12)}

  .btn-text{display:inline}
  @media (max-width: 450px), (max-height: 650px) {
    .btn-text{display:none}
  }

  /* Controls */
  .controls{
    position:absolute;
    bottom:0;
    left:0;
    right:0;
    z-index:10;
    padding:clamp(12px, 2vh, 20px);
    display:flex;
    flex-direction:column;
    gap:clamp(8px, 1.5vh, 12px);
  }

  .info-row{
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:clamp(10px, 2vw, 12px);
    opacity:0.75;
    text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  }

  .jet-btn{
    width:100%;
    height:clamp(60px, 13vh, 90px);
    background: radial-gradient(ellipse at center top, rgba(100,200,255,0.5), rgba(50,150,230,0.4) 50%, rgba(20,80,150,0.3));
    border:2px solid rgba(150,220,255,0.4);
    border-radius:999px;
    color:#fff;
    font-size:clamp(16px, 3.5vw, 20px);
    font-weight:800;
    letter-spacing:0.5px;
    cursor:pointer;
    user-select:none;
    touch-action:none;
    box-shadow:
      inset 0 -12px 24px rgba(0,0,0,0.3),
      0 8px 32px rgba(0,0,0,0.4),
      0 0 0 1px rgba(255,255,255,0.1) inset;
    transition: all 0.1s ease;
    text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    position:relative;
    overflow:hidden;
  }

  .jet-btn::before{
    content:'';
    position:absolute;
    inset:0;
    background: radial-gradient(ellipse at center, rgba(255,255,255,0.2), transparent 60%);
    opacity:0;
    transition: opacity 0.15s ease;
  }

  .jet-btn:active,
  .jet-btn.active{
    transform: translateY(2px);
    background: radial-gradient(ellipse at center top, rgba(120,220,255,0.7), rgba(70,170,250,0.6) 50%, rgba(40,100,180,0.5));
    border-color: rgba(180,240,255,0.6);
    box-shadow:
      inset 0 -18px 32px rgba(0,0,0,0.4),
      0 4px 20px rgba(0,0,0,0.5),
      0 0 0 1px rgba(255,255,255,0.15) inset,
      0 0 30px rgba(100,200,255,0.3);
  }

  .jet-btn.active::before{
    opacity:1;
  }

  /* Overlay */
  .overlay{
    position:absolute;
    inset:0;
    z-index:20;
    display:none;
    place-items:center;
    background: rgba(0,0,0,0.65);
    backdrop-filter: blur(8px);
    padding:clamp(20px, 5vw, 32px);
  }
  .overlay.show{display:grid}

  .card{
    background: rgba(15,25,45,0.95);
    border:1px solid rgba(255,255,255,0.15);
    border-radius:clamp(16px, 3vw, 20px);
    padding:clamp(24px, 5vw, 32px);
    text-align:center;
    max-width:90%;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }

  .card h2{
    margin:0 0 clamp(8px, 2vh, 12px) 0;
    font-size:clamp(22px, 5vw, 28px);
  }

  .card p{
    margin:0;
    opacity:0.85;
    font-size:clamp(14px, 3vw, 17px);
    line-height:1.5;
  }

  /* Icons */
  .icon{
    width:clamp(16px, 3.5vw, 20px);
    height:clamp(16px, 3.5vw, 20px);
    display:inline-block;
    background:currentColor;
    -webkit-mask-size:contain;
    mask-size:contain;
    -webkit-mask-repeat:no-repeat;
    mask-repeat:no-repeat;
    -webkit-mask-position:center;
    mask-position:center;
    flex-shrink:0;
  }

  .i-reset{-webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23fff" d="M12 6v3l4-4-4-4v3C6.48 4 2 8.48 2 14s4.48 10 10 10 10-4.48 10-10h-2c0 4.41-3.59 8-8 8S4 18.41 4 14 7.59 6 12 6z"/></svg>')}
  .i-pause{-webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23fff" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>')}
  .i-play{-webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23fff" d="M8 5v14l11-7z"/></svg>')}
  .i-mute{-webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23fff" d="M16.5 12l3.5 3.5-1.5 1.5L15 13.5 11.5 17l-1.5-1.5L12 12 9 9l1.5-1.5L15 10.5l3.5-3.5L20 8.5zM3 9v6h4l5 5V4L7 9H3z"/></svg>')}
  .i-sound{-webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23fff" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3a4.5 4.5 0 0 0-2.5-4v8a4.5 4.5 0 0 0 2.5-4zm-2.5-8v2a8 8 0 0 1 0 12v2c3.87-1.17 6.7-4.78 6.7-9s-2.83-7.83-6.7-9z"/></svg>')}

  @media (prefers-reduced-motion: reduce){
    *{transition:none !important}
  }
</style>
</head>
<body>
  <div id="container"></div>

  <!-- HUD -->
  <div class="hud">
    <div class="cluster">
      <div class="pill score">Score: <span id="scoreVal">0</span></div>
    </div>
    <div class="cluster">
      <button class="btn" id="resetBtn"><span class="icon i-reset"></span> <span class="btn-text">Reset</span></button>
      <button class="btn" id="pauseBtn"><span class="icon i-pause" id="pauseIcon"></span> <span class="btn-text" id="pauseText">Pause</span></button>
      <button class="btn" id="muteBtn"><span class="icon i-sound" id="muteIcon"></span> <span class="btn-text" id="muteText">Sound</span></button>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="info-row">
      <span>Hold button to activate water jet</span>
    </div>
    <button class="jet-btn" id="jetBtn">HOLD TO JET</button>
  </div>

  <!-- Pause Overlay -->
  <div class="overlay" id="pauseOverlay">
    <div class="card">
      <h2>Paused</h2>
      <p>Press <b>P</b> or tap <b>Resume</b> to continue.</p>
    </div>
  </div>

  <!-- Audio -->
  <audio id="sndBubble" preload="auto" src="data:audio/wav;base64,UklGRlYAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAAAABAAACAAAASAAAAEAAAFRkYXRhKAAAAAD8//8AAP7//wAA/v//AAD8//8AAPz//wAA/v//AAD+//8AAP3//wAA"></audio>
  <audio id="sndScore" preload="auto" src="data:audio/wav;base64,UklGRmIAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAAAABAAACAAAASAAAAEAAAFRkYXRhigAAAAD/AP//gAD//wAA//8AAP//AAD//wAA/4AAAP//AAD//wAA//8AAP+AAAD//wAA"></audio>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
/* ========================== CONFIG ========================== */
const CONFIG = {
  COLORS: [0xff6b6b, 0xffd166, 0x06d6a0, 0x4cc9f0, 0xa78bfa, 0xf472b6],
  RING_COUNT: 12,
  GRAVITY: -8.0,         // Gravity - balanced for water
  BUOYANCY: 3.5,         // Light buoyancy - rings slowly settle
  WATER_DRAG: 0.92,      // Water resistance
  JET_FORCE: 32,         // Jet force
  JET_RADIUS: 1.0,       // Jet radius
  POST_HEIGHT: 3.5,
  POST_RADIUS: 0.08,
  RING_OUTER_R: 0.35,
  RING_INNER_R: 0.27,
  RING_THICKNESS: 0.06,
  TANK_WIDTH: 4,
  TANK_HEIGHT: 6,
  TANK_DEPTH: 3,
};

/* ========================== GLOBALS ========================== */
let scene, camera, renderer, container;
let rings = [], posts = [];
let waterLevel = CONFIG.TANK_HEIGHT * 0.75;
let jetting = false, jetStartTime = 0;
let score = 0;
let paused = false, muted = false, running = true;
let clock = new THREE.Clock();
let tankMesh, waterMesh, nozzleMesh;
let jetParticles = [];

/* ========================== THREE.JS SETUP ========================== */
function initThree() {
  container = document.getElementById('container');

  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0e1a);
  scene.fog = new THREE.Fog(0x0a0e1a, 8, 16);

  // Camera
  const aspect = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
  camera.position.set(0, 4, 7);
  camera.lookAt(0, 2.5, 0);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);

  const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
  mainLight.position.set(3, 6, 4);
  mainLight.castShadow = true;
  mainLight.shadow.camera.left = -5;
  mainLight.shadow.camera.right = 5;
  mainLight.shadow.camera.top = 8;
  mainLight.shadow.camera.bottom = -2;
  mainLight.shadow.mapSize.width = 2048;
  mainLight.shadow.mapSize.height = 2048;
  scene.add(mainLight);

  const fillLight = new THREE.DirectionalLight(0x7dd3fc, 0.3);
  fillLight.position.set(-3, 2, -2);
  scene.add(fillLight);

  const rimLight = new THREE.PointLight(0xa78bfa, 0.5, 10);
  rimLight.position.set(0, 5, -3);
  scene.add(rimLight);

  // Create tank
  createTank();

  // Create posts
  createPosts();

  // Create nozzle
  createNozzle();

  // Window resize
  window.addEventListener('resize', onResize);
}

/* ========================== TANK CREATION ========================== */
function createTank() {
  // Glass tank walls (transparent)
  const tankGeo = new THREE.BoxGeometry(CONFIG.TANK_WIDTH, CONFIG.TANK_HEIGHT, CONFIG.TANK_DEPTH);
  const tankMat = new THREE.MeshPhysicalMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.15,
    metalness: 0.1,
    roughness: 0.1,
    transmission: 0.9,
    thickness: 0.5,
  });
  tankMesh = new THREE.Mesh(tankGeo, tankMat);
  tankMesh.position.y = CONFIG.TANK_HEIGHT / 2;
  scene.add(tankMesh);

  // Tank frame (edges)
  const edges = new THREE.EdgesGeometry(tankGeo);
  const lineMat = new THREE.LineBasicMaterial({ color: 0x4dd4ff, linewidth: 2 });
  const frame = new THREE.LineSegments(edges, lineMat);
  tankMesh.add(frame);

  // Water surface
  const waterGeo = new THREE.PlaneGeometry(CONFIG.TANK_WIDTH * 0.98, CONFIG.TANK_DEPTH * 0.98);
  const waterMat = new THREE.MeshPhysicalMaterial({
    color: 0x0088cc,
    transparent: true,
    opacity: 0.6,
    metalness: 0.2,
    roughness: 0.2,
    clearcoat: 1.0,
    clearcoatRoughness: 0.1,
  });
  waterMesh = new THREE.Mesh(waterGeo, waterMat);
  waterMesh.rotation.x = -Math.PI / 2;
  waterMesh.position.y = waterLevel;
  waterMesh.receiveShadow = true;
  scene.add(waterMesh);

  // Base platform
  const baseGeo = new THREE.BoxGeometry(CONFIG.TANK_WIDTH, 0.2, CONFIG.TANK_DEPTH);
  const baseMat = new THREE.MeshStandardMaterial({
    color: 0x1a2332,
    metalness: 0.4,
    roughness: 0.6,
  });
  const base = new THREE.Mesh(baseGeo, baseMat);
  base.position.y = -0.1;
  base.receiveShadow = true;
  scene.add(base);
}

/* ========================== POSTS CREATION ========================== */
function createPosts() {
  const postGeo = new THREE.CylinderGeometry(
    CONFIG.POST_RADIUS,
    CONFIG.POST_RADIUS * 1.3,
    CONFIG.POST_HEIGHT,
    16
  );
  const postMat = new THREE.MeshStandardMaterial({
    color: 0xc7d2fe,
    metalness: 0.6,
    roughness: 0.3,
    emissive: 0x6366f1,
    emissiveIntensity: 0.2,
  });

  const spacing = 0.7;
  const yPos = CONFIG.POST_HEIGHT / 2;

  [-spacing/2, spacing/2].forEach(x => {
    const post = new THREE.Mesh(postGeo, postMat.clone());
    post.position.set(x, yPos, 0);
    post.castShadow = true;
    post.receiveShadow = true;
    scene.add(post);

    posts.push({
      mesh: post,
      x: x,
      z: 0,
      topY: CONFIG.POST_HEIGHT,
      glowTime: 0,
    });

    // Top cap
    const capGeo = new THREE.SphereGeometry(CONFIG.POST_RADIUS * 1.4, 16, 12);
    const cap = new THREE.Mesh(capGeo, postMat);
    cap.position.y = CONFIG.POST_HEIGHT / 2;
    post.add(cap);
  });
}

/* ========================== NOZZLE ========================== */
function createNozzle() {
  const nozzleGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.3, 12);
  const nozzleMat = new THREE.MeshStandardMaterial({
    color: 0x94a3b8,
    metalness: 0.8,
    roughness: 0.2,
  });
  nozzleMesh = new THREE.Mesh(nozzleGeo, nozzleMat);
  nozzleMesh.position.set(0, 0.1, 1.2);
  scene.add(nozzleMesh);
}

/* ========================== RING CREATION ========================== */
function createRing(x, y, z, colorHex) {
  const shape = new THREE.Shape();
  shape.absarc(0, 0, CONFIG.RING_OUTER_R, 0, Math.PI * 2, false);

  const holePath = new THREE.Path();
  holePath.absarc(0, 0, CONFIG.RING_INNER_R, 0, Math.PI * 2, true);
  shape.holes.push(holePath);

  const extrudeSettings = {
    depth: CONFIG.RING_THICKNESS,
    bevelEnabled: true,
    bevelThickness: 0.01,
    bevelSize: 0.01,
    bevelSegments: 3,
  };

  const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  const material = new THREE.MeshStandardMaterial({
    color: colorHex,
    metalness: 0.3,
    roughness: 0.4,
    emissive: colorHex,
    emissiveIntensity: 0.15,
  });

  const ring = new THREE.Mesh(geometry, material);
  ring.rotation.x = Math.PI / 2;
  ring.position.set(x, y, z);
  ring.castShadow = true;
  ring.receiveShadow = true;
  scene.add(ring);

  return {
    mesh: ring,
    velocity: new THREE.Vector3(0, 0, 0),
    angularVel: new THREE.Vector3(
      (Math.random() - 0.5) * 1,
      (Math.random() - 0.5) * 1,
      (Math.random() - 0.5) * 1
    ),
    scored: false,
    hooked: false,
    hookedPost: null,
    mass: 0.35,
  };
}

/* ========================== SPAWN RINGS ========================== */
function spawnInitialRings() {
  rings.forEach(r => scene.remove(r.mesh));
  rings = [];

  const rows = 3;
  const cols = 4;
  const startZ = -0.8;
  const spacing = 0.45;

  for (let i = 0; i < CONFIG.RING_COUNT; i++) {
    const row = Math.floor(i / cols);
    const col = i % cols;
    const x = (col - cols / 2 + 0.5) * spacing;
    const z = startZ - row * spacing;
    const y = waterLevel - 0.8 - row * 0.15;

    const ring = createRing(x, y, z, CONFIG.COLORS[i % CONFIG.COLORS.length]);
    rings.push(ring);
  }
}

/* ========================== PHYSICS ========================== */
function updatePhysics(dt) {
  rings.forEach(ring => {
    const pos = ring.mesh.position;

    if (ring.hooked) {
      // Anchored to post
      const post = ring.hookedPost;
      const targetY = post.topY - 0.15;
      pos.y += (targetY - pos.y) * 0.12;
      pos.x += (post.x - pos.x) * 0.12;
      pos.z += (post.z - pos.z) * 0.12;
      ring.velocity.multiplyScalar(0.85);
      ring.angularVel.multiplyScalar(0.85);
      return;
    }

    // Gravity and buoyancy - slight net downward force
    let accelY = (CONFIG.GRAVITY + CONFIG.BUOYANCY) / ring.mass;
    let accelX = 0;
    let accelZ = 0;

    // Jet force - ONLY when jetting and ONLY near the nozzle
    if (jetting) {
      const nozzlePos = nozzleMesh.position;
      const dx = pos.x - nozzlePos.x;
      const dy = pos.y - nozzlePos.y;
      const dz = pos.z - nozzlePos.z;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

      // Only apply jet force within a small radius
      if (dist < CONFIG.JET_RADIUS) {
        const jetPower = 1 - (dist / CONFIG.JET_RADIUS);
        const holdTime = (Date.now() - jetStartTime) / 1000;
        const powerMult = Math.min(1 + holdTime * 0.5, 2);
        const force = CONFIG.JET_FORCE * jetPower * powerMult;

        // Upward jet force
        accelY += force / ring.mass;

        // Spread rings outward slightly from jet center
        accelX += (dx / dist) * force * 0.3 / ring.mass;
        accelZ += (dz / dist) * force * 0.3 / ring.mass;

        // Turbulence
        accelX += (Math.random() - 0.5) * 4;
        accelZ += (Math.random() - 0.5) * 4;
        ring.angularVel.x += (Math.random() - 0.5) * 6 * dt;
        ring.angularVel.z += (Math.random() - 0.5) * 6 * dt;
      }
    }

    // Apply acceleration
    ring.velocity.x += accelX * dt;
    ring.velocity.y += accelY * dt;
    ring.velocity.z += accelZ * dt;

    // Water drag
    ring.velocity.multiplyScalar(Math.pow(CONFIG.WATER_DRAG, dt));
    ring.angularVel.multiplyScalar(Math.pow(CONFIG.WATER_DRAG + 0.02, dt));

    // Update position
    pos.x += ring.velocity.x * dt;
    pos.y += ring.velocity.y * dt;
    pos.z += ring.velocity.z * dt;

    // Update rotation
    ring.mesh.rotation.x += ring.angularVel.x * dt;
    ring.mesh.rotation.y += ring.angularVel.y * dt;
    ring.mesh.rotation.z += ring.angularVel.z * dt;

    // Tank boundaries
    const wallRestitution = 0.3;
    const maxX = CONFIG.TANK_WIDTH / 2 - 0.4;
    const maxZ = CONFIG.TANK_DEPTH / 2 - 0.4;
    const minY = 0.2;
    const maxY = CONFIG.TANK_HEIGHT - 0.4;

    if (pos.x < -maxX) { pos.x = -maxX; ring.velocity.x = Math.abs(ring.velocity.x) * wallRestitution; }
    if (pos.x > maxX) { pos.x = maxX; ring.velocity.x = -Math.abs(ring.velocity.x) * wallRestitution; }
    if (pos.z < -maxZ) { pos.z = -maxZ; ring.velocity.z = Math.abs(ring.velocity.z) * wallRestitution; }
    if (pos.z > maxZ) { pos.z = maxZ; ring.velocity.z = -Math.abs(ring.velocity.z) * wallRestitution; }
    if (pos.y < minY) { pos.y = minY; ring.velocity.y = Math.abs(ring.velocity.y) * wallRestitution; }
    if (pos.y > maxY) { pos.y = maxY; ring.velocity.y = -Math.abs(ring.velocity.y) * wallRestitution; }

    // Post collision & scoring
    posts.forEach(post => {
      const dx = pos.x - post.x;
      const dz = pos.z - post.z;
      const dist2D = Math.sqrt(dx*dx + dz*dz);

      // Check if ring is around post
      if (!ring.scored && dist2D < CONFIG.RING_INNER_R && pos.y > post.topY - 0.5 && pos.y < post.topY) {
        if (Math.abs(ring.velocity.y) < 1.5) {
          ring.scored = true;
          ring.hooked = true;
          ring.hookedPost = post;
          score += 1;
          document.getElementById('scoreVal').textContent = score;
          playSound('sndScore', 0.7);

          // Glow effect
          post.glowTime = 0.8;
          post.mesh.material.emissiveIntensity = 0.8;
        }
      }

      // Push away from post body
      if (dist2D < CONFIG.POST_RADIUS * 2) {
        const pushDist = CONFIG.POST_RADIUS * 2 - dist2D;
        const nx = dx / dist2D;
        const nz = dz / dist2D;
        pos.x += nx * pushDist * 0.5;
        pos.z += nz * pushDist * 0.5;
        ring.velocity.x += nx * 2;
        ring.velocity.z += nz * 2;
      }
    });
  });

  // Ring-ring collisions
  for (let i = 0; i < rings.length; i++) {
    for (let j = i + 1; j < rings.length; j++) {
      const a = rings[i], b = rings[j];
      if (a.hooked && b.hooked) continue;

      const dx = a.mesh.position.x - b.mesh.position.x;
      const dy = a.mesh.position.y - b.mesh.position.y;
      const dz = a.mesh.position.z - b.mesh.position.z;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      const minDist = CONFIG.RING_OUTER_R * 1.8;

      if (dist > 0 && dist < minDist) {
        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        const nz = dz / dist;

        a.mesh.position.x += nx * overlap * 0.5;
        a.mesh.position.y += ny * overlap * 0.5;
        a.mesh.position.z += nz * overlap * 0.5;
        b.mesh.position.x -= nx * overlap * 0.5;
        b.mesh.position.y -= ny * overlap * 0.5;
        b.mesh.position.z -= nz * overlap * 0.5;

        const relVel = a.velocity.clone().sub(b.velocity);
        const velAlongNormal = relVel.dot(new THREE.Vector3(nx, ny, nz));
        if (velAlongNormal < 0) {
          const impulse = -1.2 * velAlongNormal;
          a.velocity.x += nx * impulse * 0.5;
          a.velocity.y += ny * impulse * 0.5;
          a.velocity.z += nz * impulse * 0.5;
          b.velocity.x -= nx * impulse * 0.5;
          b.velocity.y -= ny * impulse * 0.5;
          b.velocity.z -= nz * impulse * 0.5;
        }
      }
    }
  }

  // Update post glow
  posts.forEach(post => {
    if (post.glowTime > 0) {
      post.glowTime -= dt;
      post.mesh.material.emissiveIntensity = Math.max(0.2, post.glowTime);
    }
  });

  // Update particles
  updateJetParticles(dt);
}

/* ========================== JET PARTICLES ========================== */
function spawnJetParticles() {
  if (!jetting || paused) return;

  const particleGeo = new THREE.SphereGeometry(0.04, 6, 6);
  const particleMat = new THREE.MeshBasicMaterial({
    color: 0xe0f2fe,
    transparent: true,
    opacity: 0.7,
  });

  for (let i = 0; i < 3; i++) {
    const particle = new THREE.Mesh(particleGeo, particleMat.clone());
    const nozzlePos = nozzleMesh.position;
    particle.position.set(
      nozzlePos.x + (Math.random() - 0.5) * 0.2,
      nozzlePos.y + 0.15,
      nozzlePos.z + (Math.random() - 0.5) * 0.2
    );
    scene.add(particle);

    jetParticles.push({
      mesh: particle,
      velocity: new THREE.Vector3(
        (Math.random() - 0.5) * 1,
        2 + Math.random() * 2,
        (Math.random() - 0.5) * 1
      ),
      life: 1.0,
      age: 0,
    });
  }
}

function updateJetParticles(dt) {
  jetParticles = jetParticles.filter(p => {
    p.age += dt;
    if (p.age >= p.life) {
      scene.remove(p.mesh);
      return false;
    }

    p.velocity.y += CONFIG.GRAVITY * 0.3 * dt;
    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

    const alpha = 1 - p.age / p.life;
    p.mesh.material.opacity = alpha * 0.7;

    return true;
  });
}

/* ========================== GAME LOOP ========================== */
let lastParticleTime = 0;

function animate() {
  if (!running) return;
  requestAnimationFrame(animate);

  const dt = Math.min(clock.getDelta(), 0.033);

  if (!paused) {
    updatePhysics(dt);

    // Spawn jet particles
    if (jetting && Date.now() - lastParticleTime > 50) {
      spawnJetParticles();
      lastParticleTime = Date.now();
      if (!muted && Math.random() > 0.7) {
        playSound('sndBubble', 0.25);
      }
    }

    // Water animation
    waterMesh.position.y = waterLevel + Math.sin(Date.now() * 0.002) * 0.02;
  }

  renderer.render(scene, camera);
}

/* ========================== CONTROLS ========================== */
const jetBtn = document.getElementById('jetBtn');

function handleJetStart(e) {
  e.preventDefault();
  jetting = true;
  jetStartTime = Date.now();
  jetBtn.classList.add('active');
}

function handleJetEnd(e) {
  e.preventDefault();
  jetting = false;
  jetBtn.classList.remove('active');
}

if ('ontouchstart' in window) {
  jetBtn.addEventListener('touchstart', handleJetStart, {passive: false});
  jetBtn.addEventListener('touchend', handleJetEnd, {passive: false});
  jetBtn.addEventListener('touchcancel', handleJetEnd, {passive: false});
} else {
  jetBtn.addEventListener('pointerdown', handleJetStart);
  jetBtn.addEventListener('pointerup', handleJetEnd);
  jetBtn.addEventListener('pointerleave', handleJetEnd);
}

document.addEventListener('keydown', e => {
  if (e.code === 'Space') { handleJetStart(e); }
  if (e.code === 'KeyR') { resetGame(); }
  if (e.code === 'KeyP') { togglePause(); }
  if (e.code === 'KeyM') { toggleMute(); }
});

document.addEventListener('keyup', e => {
  if (e.code === 'Space') { handleJetEnd(e); }
});

document.getElementById('resetBtn').onclick = resetGame;
document.getElementById('pauseBtn').onclick = togglePause;
document.getElementById('muteBtn').onclick = toggleMute;

/* ========================== GAME FUNCTIONS ========================== */
function resetGame() {
  score = 0;
  document.getElementById('scoreVal').textContent = score;

  jetParticles.forEach(p => scene.remove(p.mesh));
  jetParticles = [];

  spawnInitialRings();

  paused = false;
  showPause(false);
}

function togglePause() {
  paused = !paused;
  document.getElementById('pauseText').textContent = paused ? 'Resume' : 'Pause';
  document.getElementById('pauseIcon').className = 'icon ' + (paused ? 'i-play' : 'i-pause');
  showPause(paused);
}

function toggleMute() {
  muted = !muted;
  document.getElementById('muteText').textContent = muted ? 'Muted' : 'Sound';
  document.getElementById('muteIcon').className = 'icon ' + (muted ? 'i-mute' : 'i-sound');
}

function showPause(show, title = 'Paused') {
  const overlay = document.getElementById('pauseOverlay');
  overlay.classList.toggle('show', show);
  if (title) overlay.querySelector('h2').textContent = title;
}

function playSound(id, volume = 1) {
  if (muted) return;
  try {
    const audio = document.getElementById(id).cloneNode();
    audio.volume = volume;
    audio.play();
  } catch(e) {}
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ========================== INIT ========================== */
function init() {
  initThree();
  spawnInitialRings();
  animate();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

// Public API
window.ringToss3D = {
  reset: resetGame
};
  </script>
</body>
</html>
